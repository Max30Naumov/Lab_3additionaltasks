package Naumov;

import java.util.*;

public class Main
{

    public static void main(String[] args) {

        System.out.println(task63("Тест", 5));

        System.out.println(task66("Программа"));

        System.out.println(task69("aa(())fdf"));
        System.out.println(task69("aa()()fdf())"));
    }

    /**
     * 63. Дана строка-предложение заданное кириллицей и число K (0 < K < 10).
     * Зашифровать строку, выполнив циклическую замену каждой буквы на букву
     * того же регистра, расположенную в алфавите на K-й позиции после шифруемой
     * буквы (например, для K = 2 «А» перейдет в «В», «а» — в «в», «Б» — в «Г»,
     * «я» — в «б» и т. д.). Букву «ё» в алфавите не учитывать, знаки препинания
     * и пробелы не изменять.
     */
    private static String task63(String str, int K) {
        String result = "";
        int c = 0, y = 0;
        // Далее идет реализация шифра Цезаря (передвижение на ключ)
        for (int i = 0; i < str.length(); i++) {
            c = (str.charAt(i) + K); // берем код текущего символа, передвигаем на K, дальше работаем по формуле
            // Формула для цикличного перевода в шифре Цезаря отличается для больших и маленьких букв, поэтому проверяем какая буква
            if (Character.isUpperCase(str.charAt(i))) {
                // деление по модулю используем чтобы переход был цикличным
                y = (c - 1040) % 32 + 1040; // 1040 -- это ASCI-код буквы А, 32 -- это кол-во букв в алфавите (формула для шифра Цезаря)
            } else {
                y = (c - 1072) % 32 + 1072;
            }
            result += (char) y; // получаем букву по коду, приплюсовываем к строке
        }
        return result;
    }

    /**
     * 66. Дана строка-предложение. Зашифровать ее, поместив вначале все символы, расположенные на
     * четных позициях строки, а затем, в обратном порядке, все символы, расположенные на нечетных
     * позициях (например, строка «Программа» превратится в «ргамамроП»).
     */
    private static String task66(String str) {
        // Разделяем результат на две подстроки, которые будем отдельно заполнять (левую и правую части)
        String left = "", right = "";
        // Проходимся по всем символам строки
        for (int i = 0; i < str.length(); i++) {
            // Если номер четный, то добавляем букву в конец левой подстроки
            if ((i + 1) % 2 == 0) {
                left += str.charAt(i);
                // Если номер нечетный, то добавляем букву в начало правой подстроки
            } else {
                right = str.charAt(i) + right;
            }
        }
        // Возвращаем результат
        return left + right;
    }

    /**
     * 69. Дана строка, содержащая латинские буквы и круглые скобки. Если скобки расставлены
     * правильно (т. е. каждой открывающей соответствует одна закрывающая), то вывести число 0.
     * В противном случае вывести или номер позиции, в которой расположена первая ошибочная
     * закрывающая скобка, или, если закрывающих скобок не хватает, число −1.
     */
    private static int task69(String str) {

        // Убираем со строки все символы, которые не являются скобками
        String newStr = "";
        for (int i = 0; i < str.length(); i++) {
            if (str.charAt(i) == '(' || str.charAt(i) == ')') {
                newStr += str.charAt(i);
            }
        }
        str = newStr;
        // Начинаем проверку на «сбалансированность» скобок
        // Если строка пустая -- возвращаем 0 -- ввод корректный
        if (str.isEmpty()) {
            return 0;
        } else {
            // Создаем стек для хранения скобок -- структура данных в которую можно добавить вверх и убрать сверху
            // Стек идеально подходит для проверки, поскольку проверять нам нужно только совпадение предыдущего элемента с последним
            Stack<Character> stack = new Stack<>();
            for (int i = 0; i < str.length(); i++) { // Проходимся по всем символам строки
                char current = str.charAt(i); // Берем текущий символ
                if (current == '(') { // Если скобка открывающая -- добавляем в стек
                    stack.push(current);
                } else {
                    if(stack.isEmpty()) {
                        return -1; // Случай когда есть закрывающая скобка, но нет открывающей
                    }
                    char peekChar = stack.peek(); // Смотрим на последний элемент стека, если нет закрывающей скобки, то возвращаем -1
                    if ((current == ')' && peekChar != '(')) {
                        return -1;
                    } else {
                        // Если есть закрывающая скобка, то убираем последний элемент стека
                        stack.pop();
                    }
                }
            }
            return 0;
        }
    }


}
